# Caramel Workflow Definition Platform
The caramel project aims to build a modern workflow definition platform which includes a domain specific language which can be used by developers to write complex synchronous/asynchronous workflows/pipelines.
This Workflow Definition language (WDL) is built atop exising high level Programming Langugages (starting with Java) to give developers a familiar development experience.

## Definitions
1.  A **workflow** is a combination of multiple sync/async computations, each of which could be in-memory processing, network calls to microservices, or could be workflows themselves (nested to any levels of depth forming a workflow tree.). 
    The lifecycle of a workflow execution need not be restricted to a single execution context (Process/POD/VM etc.) and can span across multiple execution contexts spread across time and deployments.
1.  A **workflow definition** defines the top-down orchestration design of a workflow.
1.  A **channel** is a logical abstraction representing a two-way data-transfer pipe - the forward direction is called an input channel and is used to send a request to a workflow
    and the reverse direction is called an output channel and is used to return the output of the workflow to it's caller. The input and output channels together compose a channel. All workflow receive and return data over channels.
    

## Design Tenets
1. **Decoupled WDL and Orchestrator**: The Workflow Definition Language should be as decoupled as possible from the underlying workflow executor allowing the same workflow to be portable across different orchestrators with differing performance characteristics
1. **Static Input Channel** : An input channel is an inherent property of a workflow. All other workflows triggering this workflow should communicate with it via its input channel.
1. **Dynamic Output Channel**: An output channel is NOT an inherent property of a workflow. It is a parameter set by the CALLER/CLIENT of the workflow.
1. **Channels abstracted from implementation**: Channels are logical entities and are not tightly coupled with implementations like APIs/Queues etc.
1. **Immutability**  is paramount: Workflows can get extremely complex and to avoid bugs and improve comprehensability of huge complex workflows, the primary data structures storing the state of a workflow execution MUST be immutable.
1. **Readability** - reading a workflow should read like reading documentation. The design of the DSL should aid such code styles.
1. **Access what you need** - any processor participating in a workflow should have a minimal input signature - it should only accept those parts of the workflow execution state data that it needs to perform its job.
1. **Persist only that is needed**: Avoid persistance of workflow execution state when it is not needed anymore.
1. **Functional Programming Paradigm**: There should be minimum side effects from business logic. Business logic should behave as functions with input and output and minimum side effects to the execution runtime. Side effects should be explicitly coded as part of the workflow definition so that developers are aware of the flow and order of side effects by reading the workflow. This also makes business logic easily testable.
1. **Common code for sync and async processing**: The definition of a workflow should not change based on whether a step in the workflow is sync or async. We should also be able to change whether a step is sync or async based on dynamic configurations or on runtime metrics.
1. **Common code from stream and batch**: Workflow definitions should not be tied to stream/batch execution contexts - i.e  the same workflow, with a few config changes, and without any code changes, should be usable in both stream and batch contexts.
1. **System independence**: Workflow definitions are entities which represent the end to end logical processing intent for a use case. Thus, workflow definitions should not be tied to systems/deployments/applications/microservices etc.. Let us say a workflow has 10 steps, and some of the steps run in one microservice while other steps run in a different micro service and these two services interact with each other via a persistent queueing datastore. It should be possible, without changing the workflow definition, just by tweaking input/output channel configurations to change the execution topology to run all the 10 steps in the same deployment by bypassing the persistent queue altogether (Useful if you want workflows to behave as simple in-memory functions which can be called from inside a batch execution context like spark Batch). (Note: this is obviously not always possible - especially if there are long-running async steps in a workflow).
1. **Optimal bypassing of optional steps**: If a partical instance of a workflow execution skips an async step 'A' because it doesn't happen to be needed in that particular case, then there should be no messages written to any persistent queue which is an input to step A. In other words, the number of IO operations in the end to end workflow should reduce proportionally with reduction in the number of steps enabled in the workflow configuration.
1. **Optimal memory and IO utilization**: One of the problems of workflow orchestration is the accumulation of potentially useless data - we keep accumulating new objects as the workflow progresses, but do not discard the old ones - even the ones which are not useful anymore. This not only leads to a higher memory footprint of the application, but in cases where there is an asynchronous step in the workflow, it leads to persisting a larger amount of data into the workflow state persistence store. One way to avoid this is for the developer to manually mark older objects for garbage collection, but this is verbose and error prone. An ideal orchestration framework should have the ability to track the usage of various objects in the workflow and automatically garbage collect the objects which no longer are needed.
1. **Optimal parallelism**: A workflow definition is generally written in a linear fashion with one step following another. But in reality, the execution itself need not be linear - the execution of the workflow can be thought of as a two dimensional lattice where different steps can be executed in parallel as long as they are independent of each other (think of a DAG). The traditional way of achieving this is for the developer to explicitly mark steps as parallelizable by manually grouping these steps which can be parallelized into different sub-workflows so that the workflow orchestrator knows that they can be parallelized. This method is verbose and subject to substantial change if and when the dependency graph changes. In some workflow definition languages, this can be done by forking out each parallelizable step into a different async step even if it is not a long-running operation. This is obviously sub-optimal and leads to unnecessary latency and I/O. An ideal workflow orchestrator should be able to detect inter-dependencies between steps and parallelize them when possible without needing to change the structure of workflow definition itself and without needing too much additional code from the developer.
1. **Cater to non-dev stakeholders** like Product managers: The workflow definition language should allow developers to cater to stakeholders like Product Managers and Ops seamlessly. When a developer adds a step in a workflow, the WDL should allow the developer to statically declare parameters used to tune that step as runtime configuration parameters which the platform can use to generate runtime dashboards where the parameters are taken as inputs and can be potentially modified by product managers/ops and other stakeholders who do not interact with code directly. For example, if a file compression step takes compression ratio as input to decide how much to compress the image, but this value can vary based on runtime parameters, the developer should be able to mark that input as a configuration parameter with its datatype - allowing it to be tweaked at runtime, either by a workflow configuration parameter or in the request itself.
 


 

